// Code generated by mdatagen. DO NOT EDIT.

package {{ .Package }}

import (
	{{- if .Metrics | parseImportsRequired }}
	"strconv"
	"fmt"
	{{- end }}
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/plog"
	{{- if or isReceiver isScraper }}
	"go.opentelemetry.io/collector/{{ .Status.Class }}"
	{{- end }}
	{{- if .SemConvVersion }}
	conventions "go.opentelemetry.io/collector/semconv/v{{ .SemConvVersion }}"
	{{- end }}
	{{ if .ResourceAttributes -}}
	"go.opentelemetry.io/collector/filter"
	{{- end }}
)

// LogsBuilder provides an interface for scrapers to report logs while taking care of all the transformations
// required to produce log representation defined in metadata and user config.
type LogsBuilder struct {
    config          LogsBuilderConfig // config of the metrics builder.
	logsBuffer plog.Logs
	buildInfo       component.BuildInfo  // contains version information.
}

// LogBuilderOption applies changes to default metrics builder.
type LogBuilderOption interface {
    apply(*LogsBuilder)
}

type logBuilderOptionFunc func(mb *LogsBuilder)

func (mbof logBuilderOptionFunc) apply(mb *LogsBuilder) {
  mbof(mb)
}

{{- if or isReceiver isScraper isConnector }}
func NewLogsBuilder(lbc LogsBuilderConfig, settings {{ .Status.Class }}.Settings, options ...LogBuilderOption) *LogsBuilder {
	mb := &LogsBuilder{
	    config: lbc,
		logsBuffer: plog.NewLogs(),
		buildInfo:     settings.BuildInfo,
	}
	return mb
}
{{- end }}

{{- if .ResourceAttributes }}
// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *LogsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(ResourceAttributesConfig{})
}
{{- end }}

// ResourceLogsOption applies changes to provided resource metrics.
type ResourceLogsOption interface {
    apply(plog.ResourceLogs)
}

type resourceLogsOptionFunc func(plog.ResourceLogs)

func (rmof resourceLogsOptionFunc) apply(rm plog.ResourceLogs) {
    rmof(rm)
}

// WithLogsResource sets the provided resource on the emitted ResourceLogs.
// It's recommended to use ResourceBuilder to create the resource.
func WithLogsResource(res pcommon.Resource) ResourceLogsOption {
	return resourceLogsOptionFunc(func(rm plog.ResourceLogs) {
		res.CopyTo(rm.Resource())
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceLogsOption arguments.
func (mb *LogsBuilder) EmitForResource(options ...ResourceLogsOption) {
	rm := plog.NewResourceLogs()
	{{- if .SemConvVersion }}
	rm.SetSchemaUrl(conventions.SchemaURL)
	{{- end }}
	ils := rm.ScopeLogs().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)

	for _, op := range options {
		op.apply(rm)
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *LogsBuilder) Emit(options ...ResourceLogsOption) plog.Logs {
	mb.EmitForResource(options...)
    logs := mb.logsBuffer
    mb.logsBuffer = plog.NewLogs()
	return logs
}
